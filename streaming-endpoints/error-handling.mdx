---
title: "Error Handling & Best Practices"
sidebarTitle: "Error Handling"
description: "Handle errors, implement reconnection strategies, and follow best practices with Python"
---

# Error Handling & Best Practices

Learn how to handle errors gracefully, implement robust reconnection strategies, and follow production-ready best practices for gRPC streaming in Python.

## gRPC Status Codes

gRPC uses standard status codes to indicate errors. Understanding these codes is essential for proper error handling in Python.

### Common Status Codes

| Code | Name | Description | Action |
|------|------|-------------|--------|
| `0` | `OK` | Success | Continue processing |
| `1` | `CANCELLED` | Operation canceled | Clean up resources |
| `3` | `INVALID_ARGUMENT` | Invalid request parameters | Fix request and retry |
| `4` | `DEADLINE_EXCEEDED` | Operation timeout | Retry with backoff |
| `7` | `PERMISSION_DENIED` | Insufficient permissions | Check account permissions |
| `14` | `UNAVAILABLE` | Service unavailable | Reconnect with backoff |
| `16` | `UNAUTHENTICATED` | Authentication failed | Refresh token and retry |

### Checking Error Codes in Python

```python
import grpc

try:
    for response in response_stream:
        # Process response
        pass

except grpc.RpcError as e:
    status_code = e.code()

    if status_code == grpc.StatusCode.UNAUTHENTICATED:
        print("Authentication failed")
    elif status_code == grpc.StatusCode.UNAVAILABLE:
        print("Service unavailable")
    elif status_code == grpc.StatusCode.INVALID_ARGUMENT:
        print("Invalid request")
    else:
        print(f"Error: {status_code} - {e.details()}")
```

---

## Common Errors and Solutions

### 1. UNAUTHENTICATED - Authentication Failed

**Causes:**
- Invalid access token
- Expired access token
- Missing authorization metadata

**Solution:**

```python
import grpc
from datetime import datetime, timedelta

def ensure_valid_token(client):
    """Ensure access token is valid, refresh if needed."""
    if not client.access_token or not client.expiration:
        # No token, need to login
        client.login(username, password)
        return

    # Check if token expires soon (within 5 minutes)
    if datetime.now(tz=client.expiration.tzinfo) > (client.expiration - timedelta(minutes=5)):
        # Token expired or expiring soon, refresh
        print("Token expired, re-authenticating...")
        client.login(username, password)

try:
    ensure_valid_token(client)
    metadata = [('authorization', client.access_token)]
    response_stream = stub.CreateMarketDataSubscription(request, metadata=metadata)

except grpc.RpcError as e:
    if e.code() == grpc.StatusCode.UNAUTHENTICATED:
        # Try refreshing token and retry once
        print("Authentication failed, refreshing token...")
        client.login(username, password)
        metadata = [('authorization', client.access_token)]
        response_stream = stub.CreateMarketDataSubscription(request, metadata=metadata)
```

### 2. UNAVAILABLE - Service Unavailable

**Causes:**
- Network connectivity issues
- Server temporarily unavailable
- Firewall blocking connection

**Solution: Exponential Backoff**

```python
import time
import random

def exponential_backoff_reconnect(connect_func, max_retries=5, base_delay=1):
    """Retry connection with exponential backoff."""
    for attempt in range(max_retries):
        try:
            return connect_func()

        except grpc.RpcError as e:
            if e.code() != grpc.StatusCode.UNAVAILABLE:
                # Not a connectivity issue, re-raise
                raise

            if attempt == max_retries - 1:
                # Last attempt failed
                raise Exception(f"Failed to connect after {max_retries} attempts")

            # Calculate delay: base_delay * 2^attempt + jitter
            delay = base_delay * (2 ** attempt) + random.uniform(0, 1)
            print(f"Service unavailable, retrying in {delay:.2f}s (attempt {attempt + 1}/{max_retries})")
            time.sleep(delay)

# Usage
def connect():
    return stub.CreateMarketDataSubscription(request, metadata=metadata)

stream = exponential_backoff_reconnect(connect)
```

### 3. INVALID_ARGUMENT - Bad Request

**Causes:**
- Invalid symbol
- Invalid depth value
- Malformed request

**Solution: Validate Input**

```python
def validate_request(symbols, depth):
    """Validate request parameters."""
    # Validate depth
    if depth < 1 or depth > 100:
        raise ValueError(f"Invalid depth: {depth}. Must be between 1 and 100.")

    # Validate symbols
    if symbols:
        for symbol in symbols:
            if not isinstance(symbol, str) or len(symbol) == 0:
                raise ValueError(f"Invalid symbol: {symbol}")

    return True

try:
    validate_request(symbols, depth)
    request = market_data_pb2.CreateMarketDataSubscriptionRequest(
        symbols=symbols,
        depth=depth
    )
except ValueError as e:
    print(f"Validation error: {e}")
```

---

## Reconnection Strategies

### Complete Reconnection Handler

```python
import grpc
import time
import logging
from datetime import datetime, timedelta

class RobustStreamer:
    def __init__(self, grpc_server, username, password):
        self.grpc_server = grpc_server
        self.username = username
        self.password = password
        self.access_token = None
        self.expiration = None
        self.max_reconnect_attempts = 10
        self.base_backoff = 1  # seconds

    def connect_and_stream(self, symbols, depth=10):
        """Connect with automatic reconnection."""
        attempt = 0

        while attempt < self.max_reconnect_attempts:
            try:
                # Ensure valid token
                self._ensure_valid_token()

                # Create channel and stub
                credentials = grpc.ssl_channel_credentials()
                channel = grpc.secure_channel(self.grpc_server, credentials)
                stub = market_data_pb2_grpc.MarketDataSubscriptionAPIStub(channel)

                # Create request
                request = market_data_pb2.CreateMarketDataSubscriptionRequest(
                    symbols=symbols,
                    depth=depth
                )

                # Start streaming
                metadata = [('authorization', self.access_token)]
                response_stream = stub.CreateMarketDataSubscription(
                    request,
                    metadata=metadata
                )

                # Reset attempt counter on successful connection
                attempt = 0

                # Process stream
                last_heartbeat = datetime.now()
                for response in response_stream:
                    if response.HasField('heartbeat'):
                        last_heartbeat = datetime.now()

                    elif response.HasField('update'):
                        # Process update
                        self._process_update(response.update)

                    # Check for stale connection
                    if (datetime.now() - last_heartbeat).total_seconds() > 60:
                        logging.warning("No heartbeat for 60s, reconnecting...")
                        break

            except grpc.RpcError as e:
                attempt += 1
                error_code = e.code()

                if error_code == grpc.StatusCode.UNAUTHENTICATED:
                    logging.error("Authentication failed, refreshing token...")
                    self._login()
                    continue

                elif error_code == grpc.StatusCode.UNAVAILABLE:
                    delay = self._calculate_backoff(attempt)
                    logging.warning(f"Service unavailable, retrying in {delay}s...")
                    time.sleep(delay)
                    continue

                else:
                    logging.error(f"Unhandled gRPC error: {error_code} - {e.details()}")
                    delay = self._calculate_backoff(attempt)
                    time.sleep(delay)
                    continue

            except KeyboardInterrupt:
                logging.info("Stream interrupted by user")
                break

            except Exception as e:
                logging.error(f"Unexpected error: {e}")
                attempt += 1
                delay = self._calculate_backoff(attempt)
                time.sleep(delay)

            finally:
                try:
                    channel.close()
                except:
                    pass

        logging.error(f"Max reconnect attempts ({self.max_reconnect_attempts}) exceeded")

    def _ensure_valid_token(self):
        """Ensure access token is valid."""
        if not self.access_token or not self.expiration:
            self._login()
            return

        # Refresh if expires within 5 minutes
        if datetime.now(tz=self.expiration.tzinfo) > (self.expiration - timedelta(minutes=5)):
            self._login()

    def _login(self):
        """Login and update token."""
        # Login implementation
        pass

    def _calculate_backoff(self, attempt):
        """Calculate exponential backoff with jitter."""
        import random
        delay = min(self.base_backoff * (2 ** attempt), 60)  # Max 60s
        jitter = random.uniform(0, 1)
        return delay + jitter

    def _process_update(self, update):
        """Process market data update."""
        pass
```

---

## Heartbeat Monitoring

Monitor heartbeats to detect stale connections early.

### Heartbeat Tracker

```python
from datetime import datetime, timedelta
import logging

class HeartbeatMonitor:
    def __init__(self, timeout_seconds=30):
        self.timeout_seconds = timeout_seconds
        self.last_heartbeat = datetime.now()

    def record_heartbeat(self):
        """Record that a heartbeat was received."""
        self.last_heartbeat = datetime.now()

    def is_alive(self):
        """Check if connection is alive based on heartbeats."""
        elapsed = (datetime.now() - self.last_heartbeat).total_seconds()
        return elapsed < self.timeout_seconds

    def time_since_last_heartbeat(self):
        """Get seconds since last heartbeat."""
        return (datetime.now() - self.last_heartbeat).total_seconds()

# Usage
monitor = HeartbeatMonitor(timeout_seconds=30)

for response in response_stream:
    if response.HasField('heartbeat'):
        monitor.record_heartbeat()

    elif response.HasField('update'):
        # Check if connection is stale
        if not monitor.is_alive():
            logging.warning(f"No heartbeat for {monitor.time_since_last_heartbeat():.1f}s")
            break  # Reconnect

        # Process update
        process_update(response.update)
```

---

## Production Best Practices

### 1. Comprehensive Logging

```python
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('grpc_stream.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# Log connection events
logger.info("Connecting to gRPC server...")
logger.info(f"Session ID: {session_id}")
logger.info(f"Subscribed to symbols: {symbols}")

# Log errors
logger.error(f"gRPC error: {e.code()} - {e.details()}")

# Log heartbeats (DEBUG level)
logger.debug("Heartbeat received")
```

### 2. Graceful Shutdown

```python
import signal
import sys

class GracefulShutdown:
    def __init__(self):
        self.shutdown_requested = False

        # Register signal handlers
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)

    def _signal_handler(self, signum, frame):
        """Handle shutdown signals."""
        print("\nShutdown requested, closing connections...")
        self.shutdown_requested = True

    def should_shutdown(self):
        """Check if shutdown was requested."""
        return self.shutdown_requested

# Usage
shutdown_handler = GracefulShutdown()

for response in response_stream:
    if shutdown_handler.should_shutdown():
        print("Shutting down gracefully...")
        break

    # Process response
    process_response(response)
```

### 3. Circuit Breaker Pattern

```python
from datetime import datetime, timedelta

class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout_seconds=60):
        self.failure_threshold = failure_threshold
        self.timeout_seconds = timeout_seconds
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN

    def record_success(self):
        """Record successful operation."""
        self.failure_count = 0
        self.state = "CLOSED"

    def record_failure(self):
        """Record failed operation."""
        self.failure_count += 1
        self.last_failure_time = datetime.now()

        if self.failure_count >= self.failure_threshold:
            self.state = "OPEN"
            print(f"Circuit breaker OPEN after {self.failure_count} failures")

    def can_attempt(self):
        """Check if operation should be attempted."""
        if self.state == "CLOSED":
            return True

        if self.state == "OPEN":
            # Check if timeout has elapsed
            if self.last_failure_time:
                elapsed = (datetime.now() - self.last_failure_time).total_seconds()
                if elapsed >= self.timeout_seconds:
                    self.state = "HALF_OPEN"
                    print("Circuit breaker entering HALF_OPEN state")
                    return True
            return False

        if self.state == "HALF_OPEN":
            return True

        return False

# Usage
circuit_breaker = CircuitBreaker(failure_threshold=3, timeout_seconds=60)

while True:
    if not circuit_breaker.can_attempt():
        print("Circuit breaker is OPEN, waiting...")
        time.sleep(10)
        continue

    try:
        # Attempt connection
        connect_and_stream()
        circuit_breaker.record_success()

    except Exception as e:
        circuit_breaker.record_failure()
        logging.error(f"Connection failed: {e}")
```

### 4. Metrics and Monitoring

```python
from collections import defaultdict
from datetime import datetime

class StreamMetrics:
    def __init__(self):
        self.metrics = {
            'messages_received': 0,
            'heartbeats_received': 0,
            'updates_received': 0,
            'errors': 0,
            'reconnections': 0,
            'last_message_time': None,
            'start_time': datetime.now()
        }
        self.error_counts = defaultdict(int)

    def record_heartbeat(self):
        self.metrics['heartbeats_received'] += 1
        self.metrics['messages_received'] += 1
        self.metrics['last_message_time'] = datetime.now()

    def record_update(self):
        self.metrics['updates_received'] += 1
        self.metrics['messages_received'] += 1
        self.metrics['last_message_time'] = datetime.now()

    def record_error(self, error_code):
        self.metrics['errors'] += 1
        self.error_counts[str(error_code)] += 1

    def record_reconnection(self):
        self.metrics['reconnections'] += 1

    def get_uptime(self):
        return (datetime.now() - self.metrics['start_time']).total_seconds()

    def print_summary(self):
        print("\n" + "="*50)
        print("Stream Metrics Summary")
        print("="*50)
        print(f"Uptime: {self.get_uptime():.2f}s")
        print(f"Messages received: {self.metrics['messages_received']}")
        print(f"Updates received: {self.metrics['updates_received']}")
        print(f"Heartbeats received: {self.metrics['heartbeats_received']}")
        print(f"Errors: {self.metrics['errors']}")
        print(f"Reconnections: {self.metrics['reconnections']}")
        if self.error_counts:
            print("\nError breakdown:")
            for code, count in self.error_counts.items():
                print(f"  {code}: {count}")
        print("="*50)

# Usage
metrics = StreamMetrics()

for response in response_stream:
    if response.HasField('heartbeat'):
        metrics.record_heartbeat()
    elif response.HasField('update'):
        metrics.record_update()

# On shutdown
metrics.print_summary()
```

---

## Next Steps

<CardGroup cols={2}>
  <Card title="Code Examples" icon="code" href="/streaming-endpoints/code-examples">
    See complete production-ready Python examples
  </Card>
  <Card title="Authentication" icon="key" href="/streaming-endpoints/authentication">
    Review authentication best practices
  </Card>
  <Card title="Market Data Stream" icon="chart-line" href="/streaming-endpoints/market-data-stream">
    Learn about market data streaming
  </Card>
  <Card title="Order Stream" icon="file-invoice" href="/streaming-endpoints/order-stream">
    Learn about order streaming
  </Card>
</CardGroup>
